<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <script type="module">
        import { generateKeyBetween, generateNKeysBetween } from 'https://cdn.jsdelivr.net/npm/fractional-indexing@3.2.0/+esm';
        
        // 전역으로 사용할 수 있도록 window 객체에 할당
        window.FractionalIndexing = { generateKeyBetween, generateNKeysBetween };
        
        // 앱 초기화
        window.initializeApp = function() {
            console.log('Fractional indexing library loaded');
        };
        
        // DOM이 로드되면 초기화 실행
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', window.initializeApp);
        } else {
            window.initializeApp();
        }
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .header {
            margin-bottom: 30px;
        }

        .document-controls {
            margin-bottom: 20px;
        }

        .document-controls input, .document-controls button {
            padding: 8px 12px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .document-controls button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }

        .document-controls button:hover {
            background-color: #0056b3;
        }

        .editor {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px;
            min-height: 400px;
        }

        .sentence-wrapper {
            position: relative;
            margin: 10px 0;
        }

        .sentence-line {
            padding: 10px;
            border: 2px solid transparent;
            border-radius: 4px;
            min-height: 20px;
            cursor: text;
            position: relative;
        }

        .sentence-line.watch-focus {
            border-color: #007bff;
            background-color: #f8f9fa;
            transition: all 0.2s ease-in-out;
        }

        .sentence-line.input-focus {
            border-color: #0056b3;
            border-width: 3px;
            background-color: white;
            transition: all 0.15s ease-in-out;
        }

        .sentence-line.input-focus:hover {
            border-color: #0056b3;
            background-color: white;
        }

        .sentence-line.empty {
            color: #999;
        }

        /* Enhanced visual focus indicators for accessibility */
        .sentence-line:focus-visible,
        .sentence-line.watch-focus {
            outline: 2px solid #007bff;
            outline-offset: 2px;
        }

        .sentence-line.input-focus {
            outline: 3px solid #0056b3;
            outline-offset: 2px;
        }

        /* Screen reader announcements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }


        .sentence-input {
            width: 100%;
            padding: 10px;
            border: none;
            outline: none;
            font-size: 16px;
            resize: none;
            min-height: 20px;
        }

        .status {
            margin-top: 20px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
            font-size: 14px;
        }

        .connected {
            color: #28a745;
        }

        .disconnected {
            color: #dc3545;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>협업 에디터</h1>
        <div class="document-controls">
            <input type="text" id="documentTitle" placeholder="문서 제목을 입력하세요">
            <button onclick="createDocument()">새 문서 만들기</button>
            <input type="text" id="documentId" placeholder="문서 ID를 입력하세요">
            <button onclick="loadDocument()">문서 불러오기</button>
        </div>
    </div>

    <div class="editor" id="editor">
        <div class="sentence-wrapper">
            <div class="sentence-line empty"
                 onclick="handleClick(this)"
                 onmouseenter="handleMouseEnter(this)"
                 onmouseleave="handleMouseLeave(this)"
                 data-id="initial"
                 data-prev-id=""></div>
        </div>
    </div>

    <div class="status">
        연결 상태: <span id="connectionStatus" class="disconnected">연결 안됨</span> |
        현재 문서: <span id="currentDocument">없음</span>
    </div>

    <!-- Screen reader announcements -->
    <div id="sr-announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>
</div>

<script>
    let stompClient = null;
    let currentDocumentId = null;
    let sentenceCounter = 0;

    function generateSentenceId() {
        return 'sentence-' + Date.now() + '-' + (++sentenceCounter);
    }

    function generateOrderKey(prevId, nextId) {
        if (!window.FractionalIndexing) {
            console.warn('Fractional indexing library not available, using timestamp fallback');
            return Date.now().toString();
        }

        // Get order values for previous and next sentences
        let prevOrder = null;
        let nextOrder = null;

        if (prevId) {
            const prevElement = document.querySelector(`[data-id="${prevId}"]`);
            if (prevElement) {
                prevOrder = prevElement.getAttribute('data-order');
            }
        }

        if (nextId) {
            const nextElement = document.querySelector(`[data-id="${nextId}"]`);
            if (nextElement) {
                nextOrder = nextElement.getAttribute('data-order');
            }
        }

        // Generate new order key between prev and next
        return window.FractionalIndexing.generateKeyBetween(prevOrder, nextOrder);
    }

    // WebSocket 연결 설정
    function connect() {
        const socket = new SockJS('/ws');
        stompClient = Stomp.over(socket);

        stompClient.connect({}, function (frame) {
            console.log('Connected: ' + frame);
            document.getElementById('connectionStatus').textContent = '연결됨';
            document.getElementById('connectionStatus').className = 'connected';

            if (currentDocumentId) {
                subscribeToDocument(currentDocumentId);
            }
        }, function (error) {
            console.log('Connection error: ', error);
            document.getElementById('connectionStatus').textContent = '연결 실패';
            document.getElementById('connectionStatus').className = 'disconnected';

            // 재연결 시도
            setTimeout(connect, 5000);
        });
    }

    function subscribeToDocument(documentId) {
        if (stompClient && stompClient.connected) {
            stompClient.subscribe('/topic/document/' + documentId, function (message) {
                const messageBody = JSON.parse(message.body);
                handleIncomingMessage(messageBody);
            });
        }
    }

    function handleIncomingMessage(messageBody) {
        // Check if this is a TwoSentenceResponse or individual SentenceResponse
        if (messageBody.firstResponse && messageBody.secondResponse) {
            // Handle TwoSentenceResponse
            console.log('Received TwoSentenceResponse:', messageBody);
            handleIncomingSentence(messageBody.firstResponse);
            handleIncomingSentence(messageBody.secondResponse);
        } else {
            // Handle individual SentenceResponse
            console.log('Received individual SentenceResponse:', messageBody);
            handleIncomingSentence(messageBody);
        }
    }

    function handleIncomingSentence(sentenceResponse) {
        console.log('Processing sentence:', sentenceResponse);

        // 문서에 새 문장 추가 또는 업데이트
        let existingSentence = document.querySelector(`[data-id="${sentenceResponse.id}"]`);

        if (existingSentence) {
            // 기존 문장 업데이트
            const safeContent = sentenceResponse.content || '';
            
            // Check if this sentence is currently in INPUT_FOCUS state
            const isCurrentlyEditing = currentFocusState === FocusState.INPUT_FOCUS && 
                                     currentFocusedElement === existingSentence;
            
            if (isCurrentlyEditing) {
                // Don't update the content if user is currently editing this sentence
                // The user's changes take precedence over incoming updates
                console.log('Skipping update for currently focused sentence:', sentenceResponse.id);
                return;
            }
            
            existingSentence.textContent = safeContent;
            if (safeContent.trim() === '') {
                existingSentence.classList.add('empty');
            } else {
                existingSentence.classList.remove('empty');
            }
        } else {
            // 새 문장 추가
            insertSentenceInOrder(sentenceResponse);
        }
    }

    function insertSentenceInOrder(sentenceData) {
        const editor = document.getElementById('editor');
        const newWrapper = createSentenceWrapper(sentenceData.id, sentenceData.prevId, sentenceData.content, sentenceData.order);

        if (sentenceData.prevId === '' || sentenceData.prevId === null) {
            // 첫 번째 문장
            editor.insertBefore(newWrapper, editor.firstChild);
        } else {
            // prevId 다음에 삽입
            const prevSentence = document.querySelector(`[data-id="${sentenceData.prevId}"]`);
            if (prevSentence) {
                const prevWrapper = prevSentence.closest('.sentence-wrapper');
                editor.insertBefore(newWrapper, prevWrapper.nextSibling);
            } else {
                // prevId를 찾을 수 없으면 마지막에 추가
                editor.appendChild(newWrapper);
            }
        }
    }

    function createSentenceWrapper(id, prevId, content, order = null) {
        const wrapper = document.createElement('div');
        wrapper.className = 'sentence-wrapper';

        // Handle undefined or null content
        const safeContent = content || '';
        
        const sentenceLine = document.createElement('div');
        sentenceLine.className = safeContent.trim() === '' ? 'sentence-line empty' : 'sentence-line';
        sentenceLine.setAttribute('data-id', id);
        sentenceLine.setAttribute('data-prev-id', prevId);
        
        // Set order attribute if provided
        if (order !== null) {
            sentenceLine.setAttribute('data-order', order);
        }
        
        sentenceLine.textContent = safeContent;
        sentenceLine.onclick = () => handleClick(sentenceLine);
        sentenceLine.onmouseenter = () => handleMouseEnter(sentenceLine);
        sentenceLine.onmouseleave = () => handleMouseLeave(sentenceLine);

        wrapper.appendChild(sentenceLine);

        return wrapper;
    }

    // 문서 생성
    async function createDocument() {
        const title = document.getElementById('documentTitle').value.trim();
        if (!title) {
            alert('문서 제목을 입력하세요.');
            return;
        }

        try {
            const response = await fetch('/api/documents', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({title: title})
            });

            if (response.ok) {
                const docData = await response.json();
                currentDocumentId = docData.id;
                document.getElementById('currentDocument').textContent = docData.title;
                document.getElementById('documentId').value = docData.id;

                // WebSocket 구독
                if (stompClient && stompClient.connected) {
                    subscribeToDocument(currentDocumentId);
                }

                // 에디터 초기화
                initializeEditor();

                alert('문서가 생성되었습니다: ' + docData.title);
            } else {
                alert('문서 생성 실패');
            }
        } catch (error) {
            console.error('Error creating document:', error);
            alert('문서 생성 중 오류가 발생했습니다.');
        }
    }

    // 문서 불러오기
    async function loadDocument() {
        const documentId = document.getElementById('documentId').value.trim();
        if (!documentId) {
            alert('문서 ID를 입력하세요.');
            return;
        }

        try {
            const response = await fetch(`/api/documents/${documentId}`);

            if (response.ok) {
                const docData = await response.json();
                currentDocumentId = docData.id;
                document.getElementById('currentDocument').textContent = docData.title;

                // WebSocket 구독
                if (stompClient && stompClient.connected) {
                    subscribeToDocument(currentDocumentId);
                }

                // 문서 내용 로드 (sentences가 있다면)
                loadDocumentContent(docData);

                alert('문서를 불러왔습니다: ' + docData.title);
            } else {
                alert('문서를 찾을 수 없습니다.');
            }
        } catch (error) {
            console.error('Error loading document:', error);
            alert('문서 불러오기 중 오류가 발생했습니다.');
        }
    }

    function loadDocumentContent(docData) {
        const editor = document.getElementById('editor');
        editor.innerHTML = '';

        // 문서에 문장이 있다면 로드, 없으면 빈 문장으로 시작
        if (docData.sentences && docData.sentences.length > 0) {
            docData.sentences.forEach(sentence => {
                const wrapper = createSentenceWrapper(sentence.id, sentence.prevId, sentence.content, sentence.order);
                editor.appendChild(wrapper);
            });
        } else {
            initializeEditor();
        }
    }

    function initializeEditor() {
        const editor = document.getElementById('editor');
        editor.innerHTML = '';

        const initialOrder = generateOrderKey(null, null); // Generate initial order key
        const wrapper = createSentenceWrapper(generateSentenceId(), '', '', initialOrder);
        editor.appendChild(wrapper);
    }

    // Three-State Focus System
    const FocusState = {
        NO_FOCUS: 'no-focus',
        WATCH_FOCUS: 'watch-focus',
        INPUT_FOCUS: 'input-focus'
    };

    let currentFocusState = FocusState.NO_FOCUS;
    let currentFocusedElement = null;
    let savedCursorPosition = 0;

    // Global keyboard event handler
    document.addEventListener('keydown', handleGlobalKeydown);

    function handleGlobalKeydown(e) {
        switch (currentFocusState) {
            case FocusState.NO_FOCUS:
                handleNoFocusKeys(e);
                break;
            case FocusState.WATCH_FOCUS:
                handleWatchFocusKeys(e);
                break;
            case FocusState.INPUT_FOCUS:
                handleInputFocusKeys(e);
                break;
        }
    }

    function handleNoFocusKeys(e) {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            transitionToWatchFocus(getFirstSentence());
        }
    }

    function handleWatchFocusKeys(e) {
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            navigateWatchFocus('up');
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            navigateWatchFocus('down');
        } else if (e.key === 'Enter' || e.key === 'ArrowLeft') {
            e.preventDefault();
            transitionToInputFocus(currentFocusedElement);
        } else if (e.key === 'Escape') {
            e.preventDefault();
            transitionToNoFocus();
        }
    }

    function handleInputFocusKeys(e) {
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            navigateInputFocus('up');
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            navigateInputFocus('down');
        } else if (e.key === 'Escape') {
            e.preventDefault();
            transitionToWatchFocus(currentFocusedElement);
        }
    }

    function transitionToNoFocus() {
        clearAllFocusStates();
        currentFocusState = FocusState.NO_FOCUS;
        currentFocusedElement = null;
        updateAccessibility();
    }

    function transitionToWatchFocus(element) {
        if (!element) return;
        clearAllFocusStates();
        element.classList.add('watch-focus');
        currentFocusState = FocusState.WATCH_FOCUS;
        currentFocusedElement = element;
        updateAccessibility();
    }

    function transitionToInputFocus(element, cursorPosition = null) {
        if (!element) return;
        clearAllFocusStates();
        element.classList.add('input-focus');
        currentFocusState = FocusState.INPUT_FOCUS;
        currentFocusedElement = element;
        editSentence(element, cursorPosition);
        updateAccessibility();
    }

    function navigateWatchFocus(direction) {
        if (!currentFocusedElement) return;

        const targetElement = getAdjacentSentence(currentFocusedElement, direction);
        if (targetElement) {
            transitionToWatchFocus(targetElement);
        }
    }

    function navigateInputFocus(direction) {
        if (!currentFocusedElement) return;

        // Save cursor position
        const textarea = currentFocusedElement.querySelector('.sentence-input');
        if (textarea) {
            savedCursorPosition = textarea.selectionStart;
            // Save without exiting focus state
            saveCurrentSentenceContent(currentFocusedElement, textarea);
        }

        // Navigate to adjacent sentence
        const targetElement = getAdjacentSentence(currentFocusedElement, direction);
        if (targetElement) {
            // Directly transition to InputFocus with saved cursor position
            transitionToInputFocus(targetElement, savedCursorPosition);
        }
    }

    function getFirstSentence() {
        return document.querySelector('.sentence-line');
    }

    function getAdjacentSentence(element, direction) {
        const currentWrapper = element.closest('.sentence-wrapper');
        let targetWrapper;

        if (direction === 'up') {
            targetWrapper = currentWrapper.previousElementSibling;
        } else {
            targetWrapper = currentWrapper.nextElementSibling;
        }

        return targetWrapper ? targetWrapper.querySelector('.sentence-line') : null;
    }

    function clearAllFocusStates() {
        document.querySelectorAll('.sentence-line').forEach(el => {
            el.classList.remove('watch-focus', 'input-focus');
            // Clear any inline background styles that might cause ghosting
            el.style.backgroundColor = '';

            // Remove any existing input forms and restore content
            const textarea = el.querySelector('.sentence-input');
            if (textarea) {
                const content = textarea.value;
                el.innerHTML = '';

                if (content.trim() === '') {
                    el.classList.add('empty');
                } else {
                    el.classList.remove('empty');
                    el.textContent = content;
                }
            }
        });
    }

    function updateAccessibility() {
        const announcements = document.getElementById('sr-announcements');

        if (currentFocusedElement) {
            switch (currentFocusState) {
                case FocusState.WATCH_FOCUS:
                    currentFocusedElement.setAttribute('aria-label', '선택된 문장, Enter 또는 왼쪽 화살표로 편집, 위/아래 화살표로 이동, ESC로 포커스 해제');
                    currentFocusedElement.setAttribute('tabindex', '0');
                    announceToScreenReader('네비게이션 모드: 문장을 선택했습니다. Enter 키로 편집하거나 화살표 키로 이동하세요.');
                    break;
                case FocusState.INPUT_FOCUS:
                    currentFocusedElement.setAttribute('aria-label', '편집 중인 문장, 위/아래 화살표로 문장 이동, ESC로 네비게이션 모드');
                    announceToScreenReader('편집 모드: 문장을 편집하고 있습니다. ESC 키로 네비게이션 모드로 돌아가세요.');
                    break;
                case FocusState.NO_FOCUS:
                    announceToScreenReader('포커스가 해제되었습니다. 위/아래 화살표 키를 눌러 네비게이션을 시작하세요.');
                    break;
            }
        }

        // Clear tabindex from non-focused elements
        document.querySelectorAll('.sentence-line').forEach(el => {
            if (el !== currentFocusedElement) {
                el.removeAttribute('tabindex');
            }
        });
    }

    function announceToScreenReader(message) {
        const announcements = document.getElementById('sr-announcements');
        if (announcements) {
            announcements.textContent = message;
            // Clear after a delay to allow screen readers to announce
            setTimeout(() => {
                announcements.textContent = '';
            }, 1000);
        }
    }

    // Mouse compatibility functions (kept for backward compatibility)
    function handleMouseEnter(element) {
        // Only show hover effect if not in any focus state
        if (currentFocusState === FocusState.NO_FOCUS) {
            element.style.backgroundColor = '#f8f9fa';
        }
    }

    function handleMouseLeave(element) {
        if (currentFocusState === FocusState.NO_FOCUS) {
            element.style.backgroundColor = '';
        }
    }

    function handleClick(element) {
        // Mouse click transitions directly to InputFocus
        transitionToInputFocus(element);
    }

    function exitInputFocus(element) {
        // Transition back to NoFocus when editing is finished
        transitionToNoFocus();
    }

    // 문장 편집
    function editSentence(element, cursorPosition = null) {
        if (element.querySelector('.sentence-input')) {
            return; // 이미 편집 중
        }

        const currentText = element.classList.contains('empty') ? '' : element.textContent;
        element.innerHTML = '';
        element.classList.remove('empty');

        const textarea = document.createElement('textarea');
        textarea.className = 'sentence-input';
        textarea.value = currentText;
        let savedByEnter = false;

        textarea.onblur = () => {
            if (!savedByEnter && currentFocusState === FocusState.INPUT_FOCUS) {
                saveCurrentSentenceContent(element, textarea);
            }
        };

        // Handle Enter key for sentence operations
        textarea.onkeydown = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                savedByEnter = true;
                handleEnterKey(element, textarea);
            }
            // Note: Arrow key navigation is handled by global handler
        };

        element.appendChild(textarea);
        textarea.focus();

        // Set cursor position - use provided position or default to end
        if (cursorPosition !== null) {
            const maxPos = textarea.value.length;
            const pos = Math.min(cursorPosition, maxPos);
            textarea.setSelectionRange(pos, pos);
        } else {
            // Default behavior: set cursor to end for InputFocus from WatchFocus
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }
    }


    function handleEnterKey(element, textarea) {
        const content = textarea.value;
        const cursorPosition = textarea.selectionStart;
        const id = element.getAttribute('data-id');
        const prevId = element.getAttribute('data-prev-id');

        if (cursorPosition === 0) {
            // Case 1: Enter at the beginning of content
            handleEnterAtBeginning(element, content, id, prevId);
        } else if (cursorPosition === content.length) {
            // Case 3: Enter at the end of content
            handleEnterAtEnd(element, content, id, prevId);
        } else {
            // Case 2: Enter in the middle of content
            handleEnterInMiddle(element, content, cursorPosition, id, prevId);
        }
    }

    function handleEnterAtBeginning(element, content, id, prevId) {
        // Create blank line above
        const newId = generateSentenceId();
        
        // Generate order for new sentence (between prevId and current sentence)
        const currentOrder = element.getAttribute('data-order');
        const newOrder = generateOrderKey(prevId, id);
        const currentNewOrder = generateOrderKey(newId, null); // Update current sentence order
        
        const newWrapper = createSentenceWrapper(newId, prevId, '', newOrder);

        // Update current sentence's prevId to new sentence ID and update order
        element.setAttribute('data-prev-id', newId);
        element.setAttribute('data-order', currentNewOrder);

        // Insert new sentence above current
        const currentWrapper = element.closest('.sentence-wrapper');
        currentWrapper.parentNode.insertBefore(newWrapper, currentWrapper);

        // Send two sentence request
        const firstRequest = { id: newId, prevId: prevId, content: '', order: newOrder };
        const secondRequest = { id: id, prevId: newId, content: content, order: currentNewOrder };

        sendTwoSentenceUpdate(firstRequest, secondRequest, () => {
            // Move cursor to beginning of next line (current line)
            finishEditing(element, content);
            setTimeout(() => {
                transitionToInputFocus(element);
                // Set cursor to beginning of line
                setTimeout(() => {
                    const textarea = element.querySelector('.sentence-input');
                    if (textarea) {
                        textarea.setSelectionRange(0, 0);
                    }
                }, 50);
            }, 0);
        });
    }

    function handleEnterAtEnd(element, content, id, prevId) {
        // Save current content and create blank line below
        const newId = generateSentenceId();
        
        // Generate order for new sentence (after current sentence)
        const currentOrder = element.getAttribute('data-order');
        const nextSibling = element.closest('.sentence-wrapper').nextElementSibling;
        const nextId = nextSibling ? nextSibling.querySelector('.sentence-line').getAttribute('data-id') : null;
        const newOrder = generateOrderKey(id, nextId);
        
        const newWrapper = createSentenceWrapper(newId, id, '', newOrder);

        // Insert new sentence below current
        const currentWrapper = element.closest('.sentence-wrapper');
        currentWrapper.parentNode.insertBefore(newWrapper, currentWrapper.nextSibling);

        // Send two sentence request
        const firstRequest = { id: id, prevId: prevId, content: content, order: currentOrder };
        const secondRequest = { id: newId, prevId: id, content: '', order: newOrder };

        sendTwoSentenceUpdate(firstRequest, secondRequest, () => {
            // Move cursor to beginning of next line
            finishEditing(element, content);
            const newSentenceLine = newWrapper.querySelector('.sentence-line');
            setTimeout(() => {
                transitionToInputFocus(newSentenceLine);
                // Set cursor to beginning of line
                setTimeout(() => {
                    const textarea = newSentenceLine.querySelector('.sentence-input');
                    if (textarea) {
                        textarea.setSelectionRange(0, 0);
                    }
                }, 50);
            }, 0);
        });
    }

    function handleEnterInMiddle(element, content, cursorPosition, id, prevId) {
        // Split content
        const beforeContent = content.substring(0, cursorPosition);
        const afterContent = content.substring(cursorPosition);

        const newId = generateSentenceId();
        
        // Generate order for new sentence (after current sentence)
        const currentOrder = element.getAttribute('data-order');
        const nextSibling = element.closest('.sentence-wrapper').nextElementSibling;
        const nextId = nextSibling ? nextSibling.querySelector('.sentence-line').getAttribute('data-id') : null;
        const newOrder = generateOrderKey(id, nextId);
        
        const newWrapper = createSentenceWrapper(newId, id, afterContent, newOrder);

        // Insert new sentence below current
        const currentWrapper = element.closest('.sentence-wrapper');
        currentWrapper.parentNode.insertBefore(newWrapper, currentWrapper.nextSibling);

        // Send two sentence request
        const firstRequest = { id: id, prevId: prevId, content: beforeContent, order: currentOrder };
        const secondRequest = { id: newId, prevId: id, content: afterContent, order: newOrder };

        sendTwoSentenceUpdate(firstRequest, secondRequest, () => {
            // Move cursor to beginning of next line
            finishEditing(element, beforeContent);
            const newSentenceLine = newWrapper.querySelector('.sentence-line');
            setTimeout(() => {
                transitionToInputFocus(newSentenceLine);
                // Set cursor to beginning of line
                setTimeout(() => {
                    const textarea = newSentenceLine.querySelector('.sentence-input');
                    if (textarea) {
                        textarea.setSelectionRange(0, 0);
                    }
                }, 50);
            }, 0);
        });
    }

    function sendTwoSentenceUpdate(firstRequest, secondRequest, callback) {
        if (stompClient && stompClient.connected && currentDocumentId) {
            const twoSentenceRequest = {
                firstRequest: {
                    id: firstRequest.id,
                    prevId: firstRequest.prevId,
                    rootDocumentId: currentDocumentId,
                    content: firstRequest.content,
                    order: firstRequest.order
                },
                secondRequest: {
                    id: secondRequest.id,
                    prevId: secondRequest.prevId,
                    rootDocumentId: currentDocumentId,
                    content: secondRequest.content,
                    order: secondRequest.order
                }
            };

            stompClient.send('/app/sentence/publish/two', {}, JSON.stringify(twoSentenceRequest));

            // Execute callback after a short delay
            if (callback) {
                setTimeout(callback, 50);
            }
        } else if (callback) {
            callback();
        }
    }

    function finishEditing(element, content) {
        // Exit input focus and return to no focus state
        exitInputFocus(element);
        element.innerHTML = '';

        if (content.trim() === '') {
            element.classList.add('empty');
        } else {
            element.classList.remove('empty');
            element.textContent = content;
        }
    }

    function saveCurrentSentenceContent(element, textarea) {
        const content = textarea.value;
        const id = element.getAttribute('data-id');
        const prevId = element.getAttribute('data-prev-id');

        // Save content without changing focus state
        element.innerHTML = '';

        if (content.trim() === '') {
            element.classList.add('empty');
        } else {
            element.classList.remove('empty');
            element.textContent = content;
        }

        // Note: We don't send individual WebSocket requests here anymore
        // Enter key operations use TwoSentenceRequest via sendTwoSentenceUpdate()
        // This function is only for UI state management
    }

    function saveSentence(element, textarea) {
        const content = textarea.value;
        const id = element.getAttribute('data-id');
        const prevId = element.getAttribute('data-prev-id');

        element.innerHTML = '';

        // Exit input focus and return to no focus state
        exitInputFocus(element);

        if (content.trim() === '') {
            element.classList.add('empty');
        } else {
            element.classList.remove('empty');
            element.textContent = content;
        }

        // WebSocket으로 전송
        if (stompClient && stompClient.connected && currentDocumentId) {
            const sentenceRequest = {
                id: id,
                prevId: prevId,
                rootDocumentId: currentDocumentId,
                content: content
            };

            stompClient.send('/app/sentence/publish', {}, JSON.stringify(sentenceRequest));
        }
    }

    // 페이지 로드 시 WebSocket 연결
    window.onload = function () {
        connect();
    };

    // 페이지 언로드 시 연결 해제
    window.onbeforeunload = function () {
        if (stompClient !== null) {
            stompClient.disconnect();
        }
    };
</script>
</body>
</html>